syntax = "proto3";

// Then the compiler also creates a separate .java file for each top-level message,
// enumeration, and service declared in the .proto file.
option java_package = "cl.ucn.fondef.sata.mini.grpc";

import "domain.proto";

// Estas son las peticiones que se enviaran desde "Backend Application"
// hasta el "Central Core" para que pueda manejar la base de datos
service WebCoreCommuService {
  rpc authenticate(CredencialesEntityReq) returns (SesionEntityReply){}

  rpc addUsuario(UsuarioEntityReq)  returns (MensajeReply) {}
  rpc getUsuario(RutEntityReq)  returns (UsuarioEntityReply) {}
  rpc getUsuarios(EmptyReq) returns (UsuariosEntityReply) {}
  rpc setUsuario(UsuarioEntityReq)  returns (MensajeReply) {}

  rpc addEquipo(EquipoEntityReq)  returns (MensajeReply){}
  rpc setEquipo(EquipoEntityReq)  returns (MensajeReply){}
  rpc getEquipo(IdElementoReq)  returns (EquipoEntityReply) {}
  rpc getEquipos(EmptyReq)  returns (EquiposEntityReply) {}
  rpc uploadArchivo(stream ArchivosEquipoEntityReq)  returns (MensajeReply){}
  rpc getArchivos(IdElementoReq)  returns (ArchivosEquipoEntityReply){}
  rpc getRegistros(RutEntityReq) returns (RegistrosReply){}

  rpc getSimulacion(IdElementoReq) returns (SimulacionReply){}
  rpc getSimulaciones(EmptyReq) returns (SimulacionesReply){}

  // va de la mano con la funcion (1) del CoreRaspiCommuService
  rpc startSimulacion(SimulacionReq) returns (MensajeReply){}

  // va de la mano con la funcion (2) del CoreRaspiCommuService
  // esta funcion busca preguntarle al Raspberry que equipo y simulacion esta corriendo
  rpc getSimulacionActual(IdElementoReq) returns (SimulacionReply){}

  // esta funcion va de la mano con (3) del CoreRaspiCommuService
  // busca obtener los valores obtenidos de los sensores como un "stream"
  // => iremos obteniendo los valores a traves del tiempo
  rpc getLecturaSensores(IdElementoReq) returns (stream LecturaSensoresReply) {}
}